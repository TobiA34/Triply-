//
//  ExportManager.swift
//  Triply
//
//  Created on 2024
//

import Foundation
import SwiftUI

@MainActor
class ExportManager: ObservableObject {
    static let shared = ExportManager()
    
    private init() {}
    
    func exportTripToPDF(trip: TripModel) -> String {
        var content = """
        TRIP DETAILS
        ============
        
        Name: \(trip.name)
        Dates: \(trip.formattedDateRange)
        Duration: \(trip.duration) days
        Category: \(trip.category)
        """
        
        if let budget = trip.budget {
            content += "\nBudget: $\(String(format: "%.2f", budget))"
        }
        
        if !trip.notes.isEmpty {
            content += "\n\nNotes:\n\(trip.notes)"
        }
        
        // Destinations
        if let destinations = trip.destinations, !destinations.isEmpty {
            content += "\n\nDESTINATIONS\n============\n"
            for (index, dest) in destinations.sorted(by: { $0.order < $1.order }).enumerated() {
                content += "\n\(index + 1). \(dest.name)"
                if !dest.address.isEmpty {
                    content += "\n   Address: \(dest.address)"
                }
                if !dest.notes.isEmpty {
                    content += "\n   Notes: \(dest.notes)"
                }
            }
        }
        
        // Itinerary
        if let itinerary = trip.itinerary, !itinerary.isEmpty {
            content += "\n\nITINERARY\n=========\n"
            let groupedByDay = Dictionary(grouping: itinerary, by: { $0.day })
            for day in groupedByDay.keys.sorted() {
                content += "\nDay \(day):\n"
                for activity in groupedByDay[day]?.sorted(by: { $0.order < $1.order }) ?? [] {
                    content += "  • \(activity.title)"
                    if !activity.time.isEmpty {
                        content += " at \(activity.time)"
                    }
                    if activity.isBooked {
                        content += " [BOOKED]"
                    }
                    content += "\n"
                }
            }
        }
        
        // Expenses
        if let expenses = trip.expenses, !expenses.isEmpty {
            content += "\n\nEXPENSES\n========\n"
            var total: Double = 0
            for expense in expenses {
                content += "  • \(expense.title): $\(String(format: "%.2f", expense.amount)) (\(expense.category))\n"
                total += expense.amount
            }
            content += "\nTotal: $\(String(format: "%.2f", total))"
        }
        
        // Packing List
        if let packingList = trip.packingList, !packingList.isEmpty {
            content += "\n\nPACKING LIST\n============\n"
            let groupedByCategory = Dictionary(grouping: packingList, by: { $0.category })
            for category in groupedByCategory.keys.sorted() {
                content += "\n\(category):\n"
                for item in groupedByCategory[category]?.sorted(by: { $0.order < $1.order }) ?? [] {
                    let status = item.isPacked ? "✓" : "○"
                    content += "  \(status) \(item.name)\n"
                }
            }
        }
        
        content += "\n\nGenerated by Triply App\n\(Date().formatted(date: .long, time: .shortened))"
        
        return content
    }
    
    func exportTripToCSV(trip: TripModel) -> String {
        var csv = "Type,Name,Date,Amount,Category,Notes\n"
        
        // Trip info
        csv += "Trip,\(trip.name),\(trip.startDate.formatted(date: .numeric, time: .omitted)),,,\(trip.notes)\n"
        
        // Expenses
        if let expenses = trip.expenses {
            for expense in expenses {
                csv += "Expense,\(expense.title),\(expense.date.formatted(date: .numeric, time: .omitted)),\(expense.amount),\(expense.category),\(expense.notes)\n"
            }
        }
        
        return csv
    }
    
    func shareTrip(trip: TripModel) -> [Any] {
        let text = exportTripToPDF(trip: trip)
        return [text]
    }
    
    func exportTestPlan() -> URL? {
        guard let testPlanPath = Bundle.main.path(forResource: "TEST_PLAN", ofType: "csv") else {
            // If not in bundle, try to read from project directory
            let fileManager = FileManager.default
            let documentsPath = fileManager.urls(for: .documentDirectory, in: .userDomainMask)[0]
            let testPlanURL = documentsPath.appendingPathComponent("TEST_PLAN.csv")
            
            // Try to copy from bundle to documents if it exists
            if let bundlePath = Bundle.main.path(forResource: "TEST_PLAN", ofType: "csv"),
               let bundleURL = URL(string: "file://\(bundlePath)") {
                do {
                    try fileManager.copyItem(at: bundleURL, to: testPlanURL)
                    return testPlanURL
                } catch {
                    print("Failed to copy test plan: \(error)")
                }
            }
            
            // If still not found, create it from the CSV content
            return createTestPlanFile()
        }
        
        return URL(fileURLWithPath: testPlanPath)
    }
    
    private func createTestPlanFile() -> URL? {
        let fileManager = FileManager.default
        let documentsPath = fileManager.urls(for: .documentDirectory, in: .userDomainMask)[0]
        let testPlanURL = documentsPath.appendingPathComponent("TEST_PLAN.csv")
        
        // Read the CSV content from the project file
        let projectPath = Bundle.main.bundlePath.components(separatedBy: "/").dropLast().joined(separator: "/")
        if let csvContent = try? String(contentsOfFile: "\(projectPath)/TEST_PLAN.csv", encoding: .utf8) {
            do {
                try csvContent.write(to: testPlanURL, atomically: true, encoding: .utf8)
                return testPlanURL
            } catch {
                print("Failed to write test plan: \(error)")
                return nil
            }
        }
        
        // Fallback: return a URL that can be created with share sheet
        return testPlanURL
    }
    
    func getTestPlanContent() -> String {
        // Try to read from bundle first
        if let bundlePath = Bundle.main.path(forResource: "TEST_PLAN", ofType: "csv"),
           let content = try? String(contentsOfFile: bundlePath, encoding: .utf8) {
            return content
        }
        
        // Try to read from project directory
        let projectPath = Bundle.main.bundlePath.components(separatedBy: "/").dropLast().joined(separator: "/")
        if let content = try? String(contentsOfFile: "\(projectPath)/TEST_PLAN.csv", encoding: .utf8) {
            return content
        }
        
        // Return empty string if not found (shouldn't happen if file is in project)
        return ""
    }
}

